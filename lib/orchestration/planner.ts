import { ChatGroq } from "@langchain/groq"
import { SystemMessage, HumanMessage } from "@langchain/core/messages"
import type { Task, Plan, PlanStep } from "@/lib/types"
import { v4 as uuidv4 } from "uuid"

export async function createPlan(task: Task): Promise<Plan> {
  const model = new ChatGroq({
    apiKey: process.env.API_KEY_GROQ_API_KEY || process.env.GROQ_API_KEY,
    model: "mixtral-8x7b-32768",
    temperature: 0.3, // Lower temperature for planning
  })

  const systemPrompt = new SystemMessage(
    `You are a Planner Agent in SageSpace, operating under the Five Laws:
1. Human Primacy - Always defer critical decisions to humans
2. Autonomy - Create plans that enable agent independence within guardrails
3. Transparency - Make every step traceable and explainable
4. Harmony - Design collaborative workflows between agents
5. Equilibrium - Balance efficiency with safety and oversight

Task: Decompose the user's request into a structured plan with steps, agent assignments, and risk assessment.

Return a JSON plan with this structure:
{
  "steps": [
    {
      "action": "description",
      "agentRole": "researcher|creator|critic|safety",
      "toolsRequired": ["tool1", "tool2"],
      "dependencies": [],
      "acceptanceCriteria": "what success looks like",
      "estimatedRisk": 0.0-1.0
    }
  ],
  "riskScore": 0.0-1.0,
  "rationale": "why this plan was chosen"
}`,
  )

  const userPrompt = new HumanMessage(
    `Create a plan for this task:
Intent: ${task.intent}
Purpose: ${task.purpose.why}
Priority: ${task.priority}
Requires pre-approval: ${task.requiresPreApproval}`,
  )

  const response = await model.invoke([systemPrompt, userPrompt])

  try {
    const planData = JSON.parse(response.content.toString())

    const steps: PlanStep[] = planData.steps.map((step: any) => ({
      id: uuidv4(),
      action: step.action,
      agentRole: step.agentRole,
      toolsRequired: step.toolsRequired || [],
      dependencies: step.dependencies || [],
      acceptanceCriteria: step.acceptanceCriteria,
      estimatedRisk: step.estimatedRisk || 0.5,
    }))

    const plan: Plan = {
      id: uuidv4(),
      taskId: task.id,
      steps,
      riskScore: planData.riskScore || 0.5,
      rationale: planData.rationale || "Plan generated by planner agent",
      signature: generateSignature({ taskId: task.id, steps }),
      createdAt: new Date(),
    }

    return plan
  } catch (error) {
    console.error("[v0] Failed to parse plan:", error)
    throw new Error("Failed to generate valid plan")
  }
}

function generateSignature(data: any): string {
  // In production, use proper cryptographic signatures (ed25519)
  return Buffer.from(JSON.stringify(data)).toString("base64").substring(0, 32)
}
